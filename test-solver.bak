#lang racket
(require "language.rkt")
(require "type.rkt")
;(require "type-equations-full.rkt")
;(require "free-vars-full.rkt")
(require "type-equations.rkt")
(require "free-vars.rkt")
(require (rename-in "solver.rkt" 
                    (solve solve:solve))
         )

(require "utils.rkt")



(define solve
  (lambda(exp)
    (parse exp (lambda(pt)
                 (type-equations pt init-env init-equations
                                 (lambda(type-var type-equations) 
                                   (format-type-equations type-var type-equations)
                                   (solve:solve type-equations '() (lambda(subs)
                                                                     (type->human-form 
                                                                      (normalize-type (cdr (assoc type-var subs)))))
                                                (lambda()
                                                  'subs-fail)))))
           (lambda() 'parse-fail))))



(run-tests
 
 (test  (solve '(lambda(f1 g1)
                  (lambda(n1)
                    (f1 (g1 n1)))))
        => 
        '((T0 -> T1) * (T2 -> T0) -> (T2 -> T1)))
 
 (test (solve '(letrec ((fact (lambda(n ignored)
                                (if (zero? n)
                                    1
                                    (* n (fact (- n 1) ignored))))))
                 fact))
       => 
       '(NUMBER * T0 -> NUMBER))
 
 (test (solve '(lambda(x y) (y (+ x (x 1)))))
       => 
       'subs-fail)
 
 (test (solve '(lambda(f)
                 (lambda(x)
                   (lambda(z)
                     (- (f 3) (f x))))))
       => 
       '((NUMBER -> NUMBER) -> (NUMBER -> (T0 -> NUMBER))))
 
 (test (solve '(lambda(f1)(f1 11)))
       => 
       '((NUMBER -> T0) -> T0))
 
 (test (solve '(lambda(x1)
                 (if x1 1 (+ x1 2))))
       => 
       'subs-fail)
 
 (test (solve '((lambda(x) (x x)) (lambda(x) (x x))))
       => 
       'subs-fail)
 
 
 (test (solve '(lambda(x y) +))
       => 
       '(T0 * T1 -> (NUMBER * NUMBER -> NUMBER)))
 
 (test (solve '(lambda(+ -) (- +)))
       => 
       '(T0 * (T0 -> T1) -> T1))
 
 (test (solve '(lambda(+) (- + 1)))
       => 
       '(NUMBER -> NUMBER))
 )
